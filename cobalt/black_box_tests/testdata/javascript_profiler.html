<!DOCTYPE html>

<head>
  <title>JavaScript Profiler Test</title>
  <script async src='black_box_js_test_utils.js'></script>
  <script>
    // Function to check if a number is prime
    const isPrime = (num) => {
      if (num <= 1) return false;
      if (num === 2) return true;
      if (num % 2 === 0) return false;

      const sqrtNum = Math.sqrt(num);
      for (let i = 3; i <= sqrtNum; i += 2) {
        if (num % i === 0) {
          return false;
        }
      }
      return true;
    }

    const testPrimeProfiler = async () => {
      const profiler = new Profiler({ sampleInterval: 10 /**ms**/, maxBufferSize: 10000 /**number of samples*/ });
      const start = performance.now();

      for (let i = 0; i < 100000; i++) {
        isPrime(i);
      }

      const duration = performance.now() - start;
      const trace = await profiler.stop();
      assertTrue(trace.length > 0, 'expected some stack traces');
    };

    const testSampleBufferFullProfiler = async () => {
      const promise = new Promise((resolve, reject) => {
        window.profiler = new Profiler({ maxBufferSize: 100, sampleInterval: 10 });
        window.profiler.addEventListener('samplebufferfull', () => {
          resolve(true);
        });
      });
      const timeoutPromise = new Promise((resolve) => {
        setTimeout(() => {
          resolve(false);
        }, 10000);
      });

      const result = await Promise.race([timeoutPromise, promise]);
      assertTrue(result, 'expected sample buffer to be full');
    };

    /**
      * Creates a new Profiler and then deletes it before the sample buffer is full.
      * Expects the SampleBuffer to be full and the callback to be executed.
    */
    const testAbruptGarbageCollection = async () => {
      const promise = new Promise((resolve, reject) => {
        window.profiler = new Profiler({ maxBufferSize: 100, sampleInterval: 10 });
        window.profiler.addEventListener('samplebufferfull', () => {
          resolve(true);
        });
      });

      // force GC. Profiler callback should still be executed even though it
      // is out of JS scope.
      h5vcc.crashLog.forceGarbageCollection();

      const timeoutPromise = new Promise((resolve) => {
        setTimeout(() => {
          resolve(false);
        }, 10000);
      });

      const result = await Promise.race([timeoutPromise, promise]);
      assertTrue(result, 'expected cobalt to not segfault if GC activates');
    };

    window.addEventListener('load', async () => {
      setupFinished();
      // Test Case 1: Prime Profiler
      await testPrimeProfiler();
      // Test Case 2: SampleBufferFull Profiler
      await testSampleBufferFullProfiler();
      // Test Case 3:
      await testAbruptGarbageCollection();
      onEndTest();
    });
  </script>
</head>

<body>
</body>
